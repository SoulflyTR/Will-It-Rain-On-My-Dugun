<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Will It Rain on My Düğün?</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.22.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "recharts": "https://aistudiocdn.com/recharts@^3.2.1"
  }
}
</script>
</head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="module">
import React, { useState, useCallback, useRef } from 'react';
import ReactDOM from 'react-dom/client';
import { GoogleGenAI, Type } from "@google/genai";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend } from 'recharts';

// --- ICONS ---

const CalendarIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" })
    )
);

const ClockIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" })
    )
);

const LocationIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" }),
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 11a3 3 0 11-6 0 3 3 0 016 0z" })
    )
);

const DownloadCsvIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }),
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M8 12h4m4 0h.01" })
    )
);

const DownloadImageIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }),
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M16 12a4 4 0 11-8 0 4 4 0 018 0z" }),
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 12h.01" })
    )
);

const DownloadJsonIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }),
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M10 12a2 2 0 100-4 2 2 0 000 4z" }),
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M14 12a2 2 0 100-4 2 2 0 000 4z" })
    )
);

// --- SERVICES ---

const WEATHER_CODE_MAP = {
    0: 'Clear sky',
    1: 'Mainly clear',
    2: 'Partly cloudy',
    3: 'Overcast',
    45: 'Fog',
    48: 'Depositing rime fog',
    51: 'Light drizzle',
    53: 'Moderate drizzle',
    55: 'Dense drizzle',
    56: 'Light freezing drizzle',
    57: 'Dense freezing drizzle',
    61: 'Slight rain',
    63: 'Moderate rain',
    65: 'Heavy rain',
    66: 'Light freezing rain',
    67: 'Heavy freezing rain',
    71: 'Slight snow fall',
    73: 'Moderate snow fall',
    75: 'Heavy snow fall',
    77: 'Snow grains',
    80: 'Slight rain showers',
    81: 'Moderate rain showers',
    82: 'Violent rain showers',
    85: 'Slight snow showers',
    86: 'Heavy snow showers',
    95: 'Thunderstorm',
    96: 'Thunderstorm with slight hail',
    99: 'Thunderstorm with heavy hail',
};

const getWeatherCodeDescription = (code) => {
    return WEATHER_CODE_MAP[code] || 'Unknown weather condition';
};

const getCoordinates = async (location) => {
  const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(location)}&count=1&language=en&format=json`;
  try {
    const response = await fetch(url);
    if (!response.ok) {
      console.error("Geocoding API error:", response.statusText);
      return null;
    }
    const data = await response.json();
    if (data.results && data.results.length > 0) {
      const { latitude, longitude } = data.results[0];
      return { latitude, longitude };
    }
    return null;
  } catch (error) {
    console.error("Failed to fetch coordinates:", error);
    return null;
  }
};

const getWeather = async (lat, lon, date) => {
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,precipitation_probability,weather_code,wind_speed_10m&daily=precipitation_probability_mean&models=gfs_global&start_date=${date}&end_date=${date}&timezone=auto`;
  try {
    const response = await fetch(url);
    if (!response.ok) {
        console.error("Weather API error:", response.statusText);
      return null;
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Failed to fetch weather:", error);
    return null;
  }
};

const getHistoricalWeather = async (lat, lon, date) => {
    const targetDate = new Date(date);
    const month = targetDate.getMonth() + 1;
    const day = targetDate.getDate();
    const currentYear = new Date().getFullYear();
    const yearsToFetch = 20;

    const promises = [];

    for (let i = 1; i <= yearsToFetch; i++) {
        const year = currentYear - i;
        const historicalDate = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        const url = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${historicalDate}&end_date=${historicalDate}&daily=weather_code,temperature_2m_mean,precipitation_sum,wind_speed_10m_mean&timezone=auto`;
        promises.push(fetch(url).then(res => res.json()));
    }

    const results = await Promise.all(promises);

    let rainyYears = 0;
    const temps = [];
    const winds = [];
    const weatherCodes = [];
    let validYears = 0;

    results.forEach(res => {
        if (res.daily && res.daily.precipitation_sum && res.daily.precipitation_sum[0] != null) {
            validYears++;
            if (res.daily.precipitation_sum[0] > 0.1) { // More than 0.1mm is a rainy day
                rainyYears++;
            }
            temps.push(res.daily.temperature_2m_mean[0]);
            winds.push(res.daily.wind_speed_10m_mean[0]);
            weatherCodes.push(res.daily.weather_code[0]);
        }
    });

    if (validYears === 0) {
        throw new Error("Could not retrieve any historical weather data for this location and date.");
    }
    
    const avgTemp = temps.reduce((a, b) => a + b, 0) / temps.length;
    const avgWind = winds.reduce((a, b) => a + b, 0) / winds.length;

    const codeFrequency = weatherCodes.reduce((acc, code) => {
        acc[code] = (acc[code] || 0) + 1;
        return acc;
    }, {});

    const mostCommonCode = Object.keys(codeFrequency).reduce((a, b) => codeFrequency[a] > codeFrequency[b] ? a : b);
    const conditions = getWeatherCodeDescription(parseInt(mostCommonCode));

    return {
        rainyYears,
        totalYears: validYears,
        avgTemp,
        avgWind,
        conditions,
    };
};

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const isHistoricalData = (data) => {
  return data.totalYears !== undefined;
}

const getForecastSummary = async (data) => {
  
  let prompt;

  if (isHistoricalData(data)) {
    prompt = `
      You are a climatologist for the 'Will It Rain on My Düğün?' app.
      You are providing a long-range climatological forecast based on historical data for this date over the past ${data.totalYears} years.
      
      Historical Data Summary:
      - It has rained on this day in ${data.rainyYears} out of the last ${data.totalYears} years.
      - Average Temperature: ${data.avgTemp.toFixed(1)}°C
      - Average Wind Speed: ${data.avgWind.toFixed(1)} km/h
      - Most Common Condition: "${data.conditions}"

      Please analyze this historical data and provide a JSON response.
      - The 'rainProbability' should be the percentage of years it has rained, calculated as (${data.rainyYears} / ${data.totalYears}) * 100, rounded to the nearest integer.
      - The 'condition' must be ONE of the following strings based on a strict hierarchical analysis: 'very wet', 'very windy', 'very hot', 'hot', 'standard', 'cold', or 'very cold'.

      Follow these rules in order:
      1. If it has rained in 40% or more of the past years, the condition is 'very wet'.
      2. If the condition is not 'very wet', and 'Average Wind Speed' is above 40 km/h, the condition is 'very windy'.
      3. If neither of the above, determine the condition based on 'Average Temperature':
          - Above 25°C: 'very hot'
          - 18°C to 25°C: 'hot'
          - 8°C to 17.9°C: 'standard'
          - 0°C to 7.9°C: 'cold'
          - Below 0°C: 'very cold'
    `;
  } else {
    const weatherDescription = getWeatherCodeDescription(data.weather_code);
    prompt = `
      You are a weather analyst for the 'Will It Rain on My Düğün?' app.
      Based on the following weather data for an event at a specific time:
      - Precipitation Probability: ${data.precipitation_probability}%
      - Temperature: ${data.temperature_2m}°C
      - Weather Description: "${weatherDescription}"
      - Wind Speed: ${data.wind_speed_10m} km/h

      Please analyze this data and provide a JSON response.
      - The 'rainProbability' must be exactly the 'Precipitation Probability' from the input data.
      - The 'condition' must be ONE of the following strings based on a strict hierarchical analysis: 'very wet', 'very windy', 'very hot', 'hot', 'standard', 'cold', or 'very cold'.

      Follow these rules in order:
      1. If 'Precipitation Probability' is 40% or higher, the condition is 'very wet'.
      2. If the condition is not 'very wet', and 'Wind Speed' is above 50 km/h, the condition is 'very windy'.
      3. If neither of the above, determine the condition based on 'Temperature':
          - Above 30°C: 'very hot'
          - 20°C to 30°C: 'hot'
          - 10°C to 19.9°C: 'standard'
          - 0°C to 9.9°C: 'cold'
          - Below 0°C: 'very cold'
    `;
  }
  
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            condition: {
                type: Type.STRING,
                description: "A single descriptor for the weather: 'very hot', 'hot', 'standard', 'cold', 'very cold', 'very windy', or 'very wet'."
            },
            rainProbability: {
                type: Type.NUMBER,
                description: "The probability of rain as a percentage (0-100)."
            },
          },
          required: ["condition", "rainProbability"],
        },
      },
    });

    const jsonText = response.text.trim();
    const parsedResponse = JSON.parse(jsonText);
    
    return parsedResponse;

  } catch (error) {
    console.error("Error calling Gemini API:", error);
    throw new Error("Failed to get a forecast summary from the AI. Please try again.");
  }
};


// --- COMPONENTS ---

const Loader = () => {
  return (
    React.createElement('div', { className: "flex flex-col items-center justify-center my-12 text-center" },
      React.createElement('div', { className: "w-12 h-12 border-4 border-purple-400 border-t-transparent rounded-full animate-spin" }),
      React.createElement('p', { className: "mt-4 text-gray-300" }, "Consulting cosmic archives & weather models...")
    )
  );
};

const DownloadButtons = ({ forecast, eventDetails, chartRef }) => {
    const isHistorical = forecast.forecastType === 'historical';
    const locationFilename = eventDetails.location.replace(/[^a-zA-Z0-9]/g, '_');
    const dateFilename = eventDetails.date;

    const createExportData = () => {
        const baseData = {
            query: { ...eventDetails, forecastType: forecast.forecastType },
            forecast: forecast.gemini,
        };

        if (isHistorical) {
            const weather = forecast.weather;
            return {
                ...baseData,
                data: weather,
                metadata: {
                    units: { avgTemp: '°C', avgWind: 'km/h' },
                    dataSource: {
                        name: "Open-Meteo Historical Weather API",
                        url: "https://open-meteo.com/en/docs/historical-weather-api"
                    }
                }
            };
        } else {
            const weather = forecast.weather;
            return {
                ...baseData,
                data: {
                    forEventTime: {
                        time: weather.time,
                        temperature_2m: weather.temperature_2m,
                        precipitation_probability: weather.precipitation_probability,
                        daily_precipitation_probability_mean: weather.daily_precipitation_probability_mean,
                        wind_speed_10m: weather.wind_speed_10m,
                        weather: getWeatherCodeDescription(weather.weather_code)
                    },
                    hourlyOutlook: forecast.hourly,
                },
                metadata: {
                    units: { temperature_2m: '°C', precipitation_probability: '%', daily_precipitation_probability_mean: '%', wind_speed_10m: 'km/h' },
                    dataSource: {
                        name: "Open-Meteo Weather Forecast API",
                        url: "https://open-meteo.com/en/docs"
                    }
                }
            };
        }
    };

    const downloadFile = (content, filename, contentType) => {
        const blob = new Blob([content], { type: contentType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    const handleJsonDownload = () => {
        const data = createExportData();
        const jsonString = JSON.stringify(data, null, 2);
        downloadFile(jsonString, `forecast_${locationFilename}_${dateFilename}.json`, 'application/json');
    };

    const handleCsvDownload = () => {
        const data = createExportData();
        let csvContent = "";

        if (isHistorical) {
            const weather = data.data;
            const headers = "location,date,forecast_type,forecast_condition,forecast_rain_probability_percent,historical_avg_temp_c,historical_avg_wind_kmh,historical_rainy_years,historical_total_years,historical_common_conditions\n";
            const row = [
                `"${eventDetails.location}"`, eventDetails.date, "historical", data.forecast.condition,
                data.forecast.rainProbability, weather.avgTemp.toFixed(1), weather.avgWind.toFixed(1),
                weather.rainyYears, weather.totalYears, `"${weather.conditions}"`
            ].join(',');
            csvContent = headers + row;
        } else {
            const dailyData = data.data;
            const weather = dailyData.forEventTime;
            const hourly = dailyData.hourlyOutlook || [];
            const headers = "location,date,time,forecast_condition,forecast_rain_probability_percent,event_time_temp_c,event_time_precip_prob_percent,event_time_daily_avg_precip_prob_percent,event_time_wind_kmh,event_time_weather_desc,hourly_time,hourly_precip_prob_percent\n";
            
            const mainRowPart = [
                 `"${eventDetails.location}"`, eventDetails.date, eventDetails.time, data.forecast.condition,
                 data.forecast.rainProbability, weather.temperature_2m, weather.precipitation_probability,
                 weather.daily_precipitation_probability_mean,
                 weather.wind_speed_10m, `"${weather.weather}"`
            ].join(',');

            if (hourly.length > 0) {
                 csvContent = headers + hourly.map(h => `${mainRowPart},${h.time},${h.precipitation}`).join('\n');
            } else {
                 csvContent = headers + mainRowPart + ",,";
            }
        }

        downloadFile(csvContent, `forecast_${locationFilename}_${dateFilename}.csv`, 'text/csv;charset=utf-8;');
    };

    const handleChartDownload = () => {
        const svgElement = chartRef.current?.querySelector('svg');
        if (!svgElement) {
            alert('Could not find the chart to download.');
            return;
        }
        
        const URL_API = window.URL || window.webkitURL;
        if (!URL_API) {
            alert('Your browser does not support this feature.');
            return;
        }

        const svgString = new XMLSerializer().serializeToString(svgElement);
        const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL_API.createObjectURL(svgBlob);

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        if (!context) {
            URL_API.revokeObjectURL(url);
            return;
        }
        
        const svgSize = svgElement.getBoundingClientRect();
        canvas.width = svgSize.width * 2;
        canvas.height = svgSize.height * 2;
        context.scale(2, 2);

        const img = new Image();
        img.onload = function() {
            context.fillStyle = '#111827';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.drawImage(img, 0, 0);
            
            const pngUrl = canvas.toDataURL('image/png');
            
            const a = document.createElement('a');
            a.href = pngUrl;
            a.download = `chart_${locationFilename}_${dateFilename}.png`;
            document.body.appendChild(a);
a.click();
            document.body.removeChild(a);
            
            URL_API.revokeObjectURL(url);
        };
        img.onerror = function() {
            URL_API.revokeObjectURL(url);
            alert('An error occurred while preparing the chart image for download.');
        };
        img.src = url;
    };


    return (
        React.createElement('div', { className: "border-t border-white/10 pt-6" },
            React.createElement('h3', { className: "text-lg font-semibold text-purple-300 mb-4 text-center" }, "Download Options"),
            React.createElement('div', { className: "flex flex-col sm:flex-row justify-center items-center gap-4" },
                React.createElement('button', { onClick: handleJsonDownload, className: "flex items-center gap-2 w-full sm:w-auto justify-center py-2 px-4 border border-white/20 rounded-lg text-sm font-medium text-white bg-gray-700/50 hover:bg-gray-600/50 transition" },
                    React.createElement(DownloadJsonIcon),
                    React.createElement('span', null, "Data (JSON)")
                ),
                React.createElement('button', { onClick: handleCsvDownload, className: "flex items-center gap-2 w-full sm:w-auto justify-center py-2 px-4 border border-white/20 rounded-lg text-sm font-medium text-white bg-gray-700/50 hover:bg-gray-600/50 transition" },
                    React.createElement(DownloadCsvIcon),
                    React.createElement('span', null, "Data (CSV)")
                ),
                !isHistorical && (
                    React.createElement('button', { onClick: handleChartDownload, className: "flex items-center gap-2 w-full sm:w-auto justify-center py-2 px-4 border border-white/20 rounded-lg text-sm font-medium text-white bg-gray-700/50 hover:bg-gray-600/50 transition" },
                        React.createElement(DownloadImageIcon),
                        React.createElement('span', null, "Chart (PNG)")
                    )
                )
            )
        )
    );
};

const groupedCities = [
    {
        country: "Turkey",
        cities: [
            { name: "Istanbul", value: "Istanbul, Turkey" },
            { name: "Ankara", value: "Ankara, Turkey" },
            { name: "İzmir", value: "Izmir, Turkey" },
            { name: "Adana", value: "Adana, Turkey" },
        ]
    },
    { country: "USA", cities: [{ name: "New York", value: "New York, USA" }] },
    { country: "UK", cities: [{ name: "London", value: "London, UK" }] },
    { country: "France", cities: [{ name: "Paris", value: "Paris, France" }] },
    { country: "Switzerland", cities: [{ name: "Zurich", value: "Zurich, Switzerland" }] },
    { country: "Japan", cities: [{ name: "Tokyo", value: "Tokyo, Japan" }] },
    { country: "Australia", cities: [{ name: "Sydney", value: "Sydney, Australia" }] },
    { country: "UAE", cities: [{ name: "Dubai", value: "Dubai, UAE" }] },
    { country: "Brazil", cities: [{ name: "Rio de Janeiro", value: "Rio de Janeiro, Brazil" }] },
    { country: "Singapore", cities: [{ name: "Singapore", value: "Singapore" }] }
];


const EventForm = ({ onSubmit, isLoading }) => {
  const [location, setLocation] = useState(groupedCities[0].cities[0].value);
  
  const today = new Date();
  const nextWeek = new Date(today);
  nextWeek.setDate(today.getDate() + 7);
  
  const [date, setDate] = useState(nextWeek.toISOString().split('T')[0]);
  const [time, setTime] = useState('14:00');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!location || !date || !time) {
        alert("Please fill in all fields.");
        return;
    }
    onSubmit({ location, date, time });
  };

  return (
    React.createElement('form', { onSubmit: handleSubmit, className: "space-y-6" },
      React.createElement('div', null,
        React.createElement('label', { htmlFor: "location", className: "block text-sm font-medium text-gray-300" }, "Location"),
        React.createElement('div', { className: "mt-1 relative" },
            React.createElement(LocationIcon),
            React.createElement('select', { id: "location", value: location, onChange: (e) => setLocation(e.target.value), className: "w-full bg-gray-900/50 border border-white/20 rounded-lg pl-10 pr-4 py-2 text-white placeholder-gray-500 focus:ring-2 focus:ring-purple-500 focus:border-purple-500 transition appearance-none", required: true },
                groupedCities.map(group => (
                    React.createElement('optgroup', { key: group.country, label: group.country, className: "font-bold text-purple-300" },
                        group.cities.map(city => (
                            React.createElement('option', { key: city.value, value: city.value, className: "bg-gray-800 text-white font-normal" }, city.name)
                        ))
                    )
                ))
            )
        )
      ),
      React.createElement('div', { className: "grid grid-cols-1 sm:grid-cols-2 gap-6" },
        React.createElement('div', null,
          React.createElement('label', { htmlFor: "date", className: "block text-sm font-medium text-gray-300" }, "Date"),
          React.createElement('div', { className: "mt-1 relative" },
            React.createElement(CalendarIcon),
            React.createElement('input', { type: "date", id: "date", value: date, onChange: (e) => setDate(e.target.value), className: "w-full bg-gray-900/50 border border-white/20 rounded-lg pl-10 pr-4 py-2 text-white placeholder-gray-500 focus:ring-2 focus:ring-purple-500 focus:border-purple-500 transition", min: new Date().toISOString().split('T')[0], required: true })
          )
        ),
        React.createElement('div', null,
          React.createElement('label', { htmlFor: "time", className: "block text-sm font-medium text-gray-300" }, "Time"),
          React.createElement('div', { className: "mt-1 relative" },
            React.createElement(ClockIcon),
            React.createElement('input', { type: "time", id: "time", value: time, onChange: (e) => setTime(e.target.value), className: "w-full bg-gray-900/50 border border-white/20 rounded-lg pl-10 pr-4 py-2 text-white placeholder-gray-500 focus:ring-2 focus:ring-purple-500 focus:border-purple-500 transition", required: true })
          )
        )
      ),
      React.createElement('div', null,
        React.createElement('button', { type: "submit", disabled: isLoading, className: "w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-purple-500 disabled:bg-gray-500 disabled:cursor-not-allowed transition-all duration-300 transform hover:scale-105" },
          isLoading ? 'Consulting the Cosmos...' : 'Check Forecast'
        )
      )
    )
  );
};

const HistoricalInfoBanner = () => (
    React.createElement('div', { className: "bg-purple-900/40 border border-purple-700 text-purple-200 px-4 py-3 rounded-lg text-center mb-6" },
        React.createElement('p', { className: "font-semibold" }, "Climatological Forecast"),
        React.createElement('p', { className: "text-sm" }, "This long-range forecast is based on historical weather trends over the past 20 years for this date.")
    )
);

const DailyStats = ({ weather }) => (
    React.createElement(React.Fragment, null,
        React.createElement('div', null,
            React.createElement('p', { className: "text-sm text-gray-400" }, "Prob. (Event Time)"),
            React.createElement('p', { className: "text-2xl font-semibold" }, `${weather.precipitation_probability}%`)
        ),
        weather.daily_precipitation_probability_mean !== null && React.createElement('div', null,
            React.createElement('p', { className: "text-sm text-gray-400" }, "Daily Avg. Rain"),
            React.createElement('p', { className: "text-2xl font-semibold" }, `${Math.round(weather.daily_precipitation_probability_mean)}%`)
        ),
        React.createElement('div', null,
            React.createElement('p', { className: "text-sm text-gray-400" }, "Temperature"),
            React.createElement('p', { className: "text-2xl font-semibold" }, `${Math.round(weather.temperature_2m)}°C`)
        ),
        React.createElement('div', null,
            React.createElement('p', { className: "text-sm text-gray-400" }, "Wind Speed"),
            React.createElement('p', { className: "text-2xl font-semibold" }, `${Math.round(weather.wind_speed_10m)} km/h`)
        ),
        React.createElement('div', null,
            React.createElement('p', { className: "text-sm text-gray-400" }, "Conditions"),
            React.createElement('p', { className: "text-xl font-semibold" }, getWeatherCodeDescription(weather.weather_code))
        )
    )
);

const HistoricalStats = ({ weather }) => (
     React.createElement(React.Fragment, null,
        React.createElement('div', null,
            React.createElement('p', { className: "text-sm text-gray-400" }, "Rainy Days"),
            React.createElement('p', { className: "text-2xl font-semibold" }, `${weather.rainyYears} / ${weather.totalYears} yrs`)
        ),
        React.createElement('div', null,
            React.createElement('p', { className: "text-sm text-gray-400" }, "Avg. Temp"),
            React.createElement('p', { className: "text-2xl font-semibold" }, `${Math.round(weather.avgTemp)}°C`)
        ),
        React.createElement('div', null,
            React.createElement('p', { className: "text-sm text-gray-400" }, "Avg. Wind"),
            React.createElement('p', { className: "text-2xl font-semibold" }, `${Math.round(weather.avgWind)} km/h`)
        ),
        React.createElement('div', null,
            React.createElement('p', { className: "text-sm text-gray-400" }, "Commonly"),
            React.createElement('p', { className: "text-xl font-semibold" }, weather.conditions)
        )
    )
);


const ForecastDisplay = ({ forecast, eventDetails }) => {
  const { gemini, weather, hourly, forecastType } = forecast;
  const isHistorical = forecastType === 'historical';
  const chartRef = useRef(null);

  const eventTime = new Date(`${eventDetails.date}T${eventDetails.time}`).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
  const eventDate = new Date(eventDetails.date + 'T00:00:00').toLocaleDateString([], { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

  const getBackgroundColor = (condition, probability) => {
    if (condition === 'very wet' || probability >= 40) return 'bg-blue-900/40';
    if (condition === 'very hot') return 'bg-red-900/40';
    if (condition === 'hot') return 'bg-orange-900/40';
    if (condition === 'standard') return 'bg-green-900/40';
    if (condition === 'cold') return 'bg-cyan-900/40';
    if (condition === 'very cold') return 'bg-sky-900/40';
    if (condition === 'very windy') return 'bg-teal-900/40';
    return 'bg-green-900/40';
  };

  return (
    React.createElement('div', { className: "mt-8 animate-fade-in" },
        React.createElement('div', { className: `text-center p-8 rounded-t-2xl border-x border-t border-white/10 ${getBackgroundColor(gemini.condition, gemini.rainProbability)}` },
            React.createElement('p', { className: "text-xl text-gray-300" }, `Forecast for ${eventDetails.location} on`),
            React.createElement('p', { className: "text-xl text-gray-300" }, eventDate),
            React.createElement('h2', { className: "text-5xl font-bold mt-4 mb-2 tracking-tight capitalize" }, gemini.condition),
            React.createElement('p', { className: "text-6xl font-bold" }, `${Math.round(gemini.rainProbability)}%`),
            React.createElement('p', { className: "text-lg text-gray-300" }, "Chance of Rain")
        ),
        React.createElement('div', { className: "bg-white/5 p-8 rounded-b-2xl shadow-2xl border border-white/10 backdrop-blur-sm space-y-8" },
            isHistorical && React.createElement(HistoricalInfoBanner),
            
            !isHistorical && hourly && (
                React.createElement('div', null,
                    React.createElement('h3', { className: "text-lg font-semibold text-purple-300 mb-4" }, `Hourly Precipitation Outlook (around ${eventTime})`),
                    React.createElement('div', { className: "h-64 w-full", ref: chartRef },
                        React.createElement(ResponsiveContainer, { width: "100%", height: "100%" },
                            React.createElement(LineChart, { data: hourly, margin: { top: 5, right: 20, left: -10, bottom: 5 } },
                                React.createElement(CartesianGrid, { strokeDasharray: "3 3", stroke: "rgba(255, 255, 255, 0.1)" }),
                                React.createElement(XAxis, { dataKey: "time", stroke: "#9ca3af", fontSize: 12 }),
                                React.createElement(YAxis, { unit: "%", stroke: "#9ca3af", fontSize: 12, domain: [0, 100] }),
                                React.createElement(Tooltip, {
                                    contentStyle: {
                                        backgroundColor: 'rgba(30, 41, 59, 0.8)',
                                        borderColor: 'rgba(255, 255, 255, 0.2)',
                                        borderRadius: '0.5rem',
                                    },
                                    labelStyle: { color: '#d1d5db' },
                                }),
                                React.createElement(Legend, { wrapperStyle: { fontSize: "14px" } }),
                                React.createElement(Line, { type: "monotone", dataKey: "precipitation", name: "Chance of Rain", stroke: "#a78bfa", strokeWidth: 3, dot: { r: 4 }, activeDot: { r: 8 } })
                            )
                        )
                    )
                )
            ),
            React.createElement('div', { className: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-4 text-center border-t border-white/10 pt-6" },
                isHistorical 
                    ? React.createElement(HistoricalStats, { weather: weather }) 
                    : React.createElement(DailyStats, { weather: weather })
            ),
            React.createElement(DownloadButtons, { forecast: forecast, eventDetails: eventDetails, chartRef: chartRef })
        )
    )
  );
};

const App = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [forecast, setForecast] = useState(null);
  const [eventDetails, setEventDetails] = useState(null);

  const handleFormSubmit = useCallback(async (details) => {
    setIsLoading(true);
    setError(null);
    setForecast(null);
    setEventDetails(details);

    try {
      const coordinates = await getCoordinates(details.location);
      if (!coordinates) {
        throw new Error("Could not find location. Please try a more specific address or city.");
      }

      const eventDate = new Date(details.date + 'T00:00:00');
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const diffTime = eventDate.getTime() - today.getTime();
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

      if (diffDays <= 15) {
        const weather = await getWeather(coordinates.latitude, coordinates.longitude, details.date);
        if (!weather || !weather.hourly || weather.hourly.time.length === 0) {
          throw new Error("Could not retrieve weather data for the specified date.");
        }
        
        const eventDateTime = new Date(`${details.date}T${details.time}`);
        const eventHourIndex = weather.hourly.time.findIndex(t => new Date(t).getHours() === eventDateTime.getHours());

        if (eventHourIndex === -1) {
          throw new Error("Weather data for the specific time is not available. Please try an earlier time on the same day.");
        }
        
        const relevantWeatherData = {
          time: weather.hourly.time[eventHourIndex],
          temperature_2m: weather.hourly.temperature_2m[eventHourIndex],
          precipitation_probability: weather.hourly.precipitation_probability[eventHourIndex],
          weather_code: weather.hourly.weather_code[eventHourIndex],
          wind_speed_10m: weather.hourly.wind_speed_10m[eventHourIndex],
          daily_precipitation_probability_mean: weather.daily?.precipitation_probability_mean?.[0] ?? null,
        };

        const chartDataStart = Math.max(0, eventHourIndex - 3);
        const chartDataEnd = Math.min(weather.hourly.time.length, eventHourIndex + 4);
        const hourlyChartData = weather.hourly.time.slice(chartDataStart, chartDataEnd).map((time, i) => ({
          time: new Date(time).toLocaleTimeString([], { hour: 'numeric', hour12: true }),
          precipitation: weather.hourly.precipitation_probability[chartDataStart + i],
        }));

        const geminiResponse = await getForecastSummary(relevantWeatherData);
        
        setForecast({
          forecastType: 'daily',
          gemini: geminiResponse,
          weather: relevantWeatherData,
          hourly: hourlyChartData
        });

      } else {
        const historicalData = await getHistoricalWeather(coordinates.latitude, coordinates.longitude, details.date);
        const geminiResponse = await getForecastSummary(historicalData);

        setForecast({
          forecastType: 'historical',
          gemini: geminiResponse,
          weather: historicalData,
        });
      }

    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError("An unknown error occurred.");
      }
    } finally {
      setIsLoading(false);
    }
  }, []);

  return (
    React.createElement('div', { className: "min-h-screen bg-gray-900 bg-[radial-gradient(ellipse_80%_80%_at_50%_-20%,rgba(120,119,198,0.3),rgba(255,255,255,0))]"},
      React.createElement('main', { className: "container mx-auto px-4 py-8 md:py-16" },
        React.createElement('header', { className: "text-center mb-12" },
          React.createElement('h1', { className: "text-4xl md:text-6xl font-bold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-purple-400 via-pink-400 to-white" }, "Will It Rain on My Düğün?"),
          React.createElement('p', { className: "mt-4 text-lg text-gray-300 max-w-2xl mx-auto" }, "An intelligent forecaster for your outdoor events, powered by NASA data and AI.")
        ),
        React.createElement('div', { className: "max-w-2xl mx-auto" },
            React.createElement('div', { className: "bg-white/5 p-8 rounded-2xl shadow-2xl border border-white/10 backdrop-blur-sm" },
                React.createElement(EventForm, { onSubmit: handleFormSubmit, isLoading: isLoading })
            ),
            isLoading && React.createElement(Loader),
            error && (
                React.createElement('div', { className: "mt-8 bg-red-900/50 border border-red-700 text-red-200 px-4 py-3 rounded-lg text-center" },
                    React.createElement('p', { className: "font-semibold" }, "Oh no! An error occurred."),
                    React.createElement('p', null, error)
                )
            ),
            forecast && eventDetails && !isLoading && (
              React.createElement(ForecastDisplay, { forecast: forecast, eventDetails: eventDetails })
            )
        ),
        React.createElement('footer', { className: "text-center mt-16 text-gray-500 text-sm" },
          React.createElement('p', null, "This project utilizes data derived from sources like the NASA GPM mission, aggregated through open meteorological APIs."),
          React.createElement('p', null, "© Lemniscate, 2025")
        )
      )
    )
  );
};


// --- RENDER ---
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}
const root = ReactDOM.createRoot(rootElement);
root.render(
  React.createElement(React.StrictMode, null, React.createElement(App))
);
    </script>
  </body>
</html>